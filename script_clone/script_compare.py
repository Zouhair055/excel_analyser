import pandas as pd
import os
from datetime import datetime
import tkinter as tk
from tkinter import filedialog

class TrainingVsOutputComparator:
    """Compare le fichier d'entra√Ænement (vraies valeurs) avec la sortie du syst√®me"""
    
    def __init__(self):
        self.target_columns = ['Nature', 'Descrip', 'Vessel', 'Service', 'Reference']
        
    def select_files_gui(self):
        """S√©lection des fichiers avec des labels corrects"""
        
        root = tk.Tk()
        root.withdraw()
        
        print("üéØ COMPARAISON ENTRA√éNEMENT vs SORTIE SYST√àME")
        print("=" * 60)
        print("üìã Workflow:")
        print("   1. Fichier d'entra√Ænement = vraies valeurs compl√®tes")
        print("   2. Fichier de sortie = colonnes remplies par le syst√®me")
        print("   3. Comparaison = performance du syst√®me de r√®gles")
        print()
        
        # S√©lection fichier d'entra√Ænement (vraies valeurs)
        print("üìÅ S√©lection du fichier D'ENTRA√éNEMENT (vraies valeurs)...")
        training_file = filedialog.askopenfilename(
            title="üìÅ Fichier d'Entra√Ænement (avec VRAIES valeurs)",
            filetypes=[("Fichiers Excel", "*.xlsx *.xls"), ("Tous les fichiers", "*.*")]
        )
        
        if not training_file:
            print("‚ùå Aucun fichier d'entra√Ænement s√©lectionn√©")
            root.destroy()
            return None, None
        
        print(f"‚úÖ Fichier d'entra√Ænement: {os.path.basename(training_file)}")
        
        # S√©lection fichier de sortie (rempli par le syst√®me)
        print("\nüìÅ S√©lection du fichier de SORTIE (rempli par le syst√®me)...")
        output_file = filedialog.askopenfilename(
            title="üìÅ Fichier de Sortie (rempli par le syst√®me)",
            filetypes=[("Fichiers Excel", "*.xlsx *.xls"), ("Tous les fichiers", "*.*")]
        )
        
        if not output_file:
            print("‚ùå Aucun fichier de sortie s√©lectionn√©")
            root.destroy()
            return None, None
        
        print(f"‚úÖ Fichier de sortie: {os.path.basename(output_file)}")
        
        root.destroy()
        return training_file, output_file
    
    def find_data_start_row(self, filepath):
        """Trouve o√π commencent les donn√©es (m√™me logique que l'app)"""
        try:
            df_preview = pd.read_excel(filepath, header=None, nrows=15)
            
            for idx, row in df_preview.iterrows():
                row_str = ' '.join([str(cell) for cell in row if pd.notna(cell)]).lower()
                if 'description' in row_str:
                    return idx
            
            for idx, row in df_preview.iterrows():
                non_null_count = row.notna().sum()
                if non_null_count >= 5:
                    row_str = ' '.join([str(cell) for cell in row if pd.notna(cell)]).lower()
                    keywords = ['date', 'amount', 'entity', 'nature', 'vessel', 'service', 'period']
                    if any(keyword in row_str for keyword in keywords):
                        return idx
            return 0
        except Exception:
            return 0
    
    def read_excel_smart(self, filepath):
        """Lecture intelligente du fichier"""
        start_row = self.find_data_start_row(filepath)
        df = pd.read_excel(filepath, header=start_row)
        df.columns = [str(col).strip() if pd.notna(col) else f'Unnamed_{i}' for i, col in enumerate(df.columns)]
        df = df.dropna(how='all')
        return df
    
    def compare_training_vs_output(self, training_file, output_file):
        """Compare l'entra√Ænement (vraies valeurs) avec la sortie du syst√®me"""
        
        print("\n" + "üéØ ANALYSE DE PERFORMANCE DU SYST√àME" + "="*30)
        print(f"üìö Fichier d'entra√Ænement: {os.path.basename(training_file)}")
        print(f"ü§ñ Fichier de sortie: {os.path.basename(output_file)}")
        
        try:
            # Charger les fichiers
            df_training = self.read_excel_smart(training_file)
            df_output = self.read_excel_smart(output_file)
            
            print(f"\nüìä Structure des fichiers:")
            print(f"   ‚Ä¢ Entra√Ænement: {len(df_training)} lignes, {len(df_training.columns)} colonnes")
            print(f"   ‚Ä¢ Sortie: {len(df_output)} lignes, {len(df_output.columns)} colonnes")
            
            # V√©rifier que les structures correspondent
            if len(df_training) != len(df_output):
                print("‚ö†Ô∏è Nombre de lignes diff√©rent - alignement des fichiers")
                min_rows = min(len(df_training), len(df_output))
                df_training = df_training.head(min_rows)
                df_output = df_output.head(min_rows)
            
            # Analyser chaque colonne cible
            self._analyze_system_performance(df_training, df_output)
            
            # V√©rifier que les autres colonnes n'ont pas chang√©
            self._verify_unchanged_columns(df_training, df_output)
            
            # Rapport final de performance
            self._print_performance_report()
            
        except Exception as e:
            print(f"‚ùå Erreur: {e}")
            import traceback
            traceback.print_exc()
    
    def _analyze_system_performance(self, df_training, df_output):
        """Analyse la performance du syst√®me pour chaque colonne"""
        
        print("\n" + "üéØ PERFORMANCE PAR COLONNE CIBLE" + "="*35)
        
        self.performance_stats = {}
        self.total_correct = 0
        self.total_predicted = 0
        self.total_should_predict = 0
        
        for column in self.target_columns:
            print(f"\nüìç Analyse de la colonne: {column}")
            print("-" * 50)
            
            if column not in df_training.columns:
                print(f"‚ùå Colonne '{column}' manquante dans l'entra√Ænement")
                continue
                
            if column not in df_output.columns:
                print(f"‚ùå Colonne '{column}' manquante dans la sortie")
                continue
            
            # Statistiques pour cette colonne
            correct_predictions = 0
            total_predictions = 0
            false_positives = 0
            missed_predictions = 0
            
            print(f"üìä √âchantillon de comparaison (10 premi√®res lignes):")
            print(f"{'Ligne':<6} {'Vraie Valeur':<25} {'Pr√©diction':<25} {'R√©sultat':<15}")
            print("-" * 75)
            
            for idx in range(min(len(df_training), 10)):
                true_val = self._normalize_value(df_training.iloc[idx][column])
                pred_val = self._normalize_value(df_output.iloc[idx][column])
                
                if true_val != '' and pred_val != '':
                    # Le syst√®me a pr√©dit quelque chose pour une vraie valeur
                    if true_val == pred_val:
                        result = "‚úÖ CORRECT"
                        correct_predictions += 1
                    else:
                        result = "‚ùå INCORRECT"
                        false_positives += 1
                    total_predictions += 1
                    print(f"{idx+1:<6} {true_val[:24]:<25} {pred_val[:24]:<25} {result:<15}")
                    
                elif true_val != '' and pred_val == '':
                    # Le syst√®me a rat√© une valeur qu'il aurait d√ª pr√©dire
                    result = "‚ö†Ô∏è RAT√â"
                    missed_predictions += 1
                    if idx < 5:  # Afficher seulement les 5 premi√®res
                        print(f"{idx+1:<6} {true_val[:24]:<25} {'(vide)':<25} {result:<15}")
                
                elif true_val == '' and pred_val != '':
                    # Le syst√®me a pr√©dit l√† o√π il n'y avait rien
                    result = "üîÑ NOUVEAU"
                    total_predictions += 1
                    if idx < 3:  # Afficher seulement les 3 premi√®res
                        print(f"{idx+1:<6} {'(vide)':<25} {pred_val[:24]:<25} {result:<15}")
            
            # Calculer les statistiques compl√®tes
            total_correct_for_col = 0
            total_predicted_for_col = 0
            total_should_predict_for_col = 0
            total_missed_for_col = 0
            
            for idx in range(len(df_training)):
                true_val = self._normalize_value(df_training.iloc[idx][column])
                pred_val = self._normalize_value(df_output.iloc[idx][column])
                
                if true_val != '':
                    total_should_predict_for_col += 1
                    
                if pred_val != '':
                    total_predicted_for_col += 1
                    
                if true_val != '' and pred_val == true_val:
                    total_correct_for_col += 1
                    
                if true_val != '' and pred_val == '':
                    total_missed_for_col += 1
            
            # M√©triques de performance
            accuracy = (total_correct_for_col / total_should_predict_for_col * 100) if total_should_predict_for_col > 0 else 0
            precision = (total_correct_for_col / total_predicted_for_col * 100) if total_predicted_for_col > 0 else 0
            recall = (total_correct_for_col / total_should_predict_for_col * 100) if total_should_predict_for_col > 0 else 0
            
            print(f"\nüìä M√©triques pour {column}:")
            print(f"   ‚Ä¢ Valeurs √† pr√©dire: {total_should_predict_for_col}")
            print(f"   ‚Ä¢ Pr√©dictions faites: {total_predicted_for_col}")
            print(f"   ‚Ä¢ Pr√©dictions correctes: {total_correct_for_col}")
            print(f"   ‚Ä¢ Valeurs rat√©es: {total_missed_for_col}")
            print(f"   ‚Ä¢ üéØ Pr√©cision: {accuracy:.1f}% (bonnes r√©ponses/total √† pr√©dire)")
            print(f"   ‚Ä¢ üîç Rappel: {recall:.1f}% (bonnes r√©ponses/total √† pr√©dire)")
            print(f"   ‚Ä¢ ‚ö° Efficacit√©: {precision:.1f}% (bonnes r√©ponses/pr√©dictions faites)")
            
            # Stocker les stats
            self.performance_stats[column] = {
                'total_should_predict': total_should_predict_for_col,
                'total_predicted': total_predicted_for_col,
                'correct_predictions': total_correct_for_col,
                'missed': total_missed_for_col,
                'accuracy': accuracy,
                'precision': precision,
                'recall': recall
            }
            
            # Mettre √† jour les totaux
            self.total_correct += total_correct_for_col
            self.total_predicted += total_predicted_for_col
            self.total_should_predict += total_should_predict_for_col
    
    def _verify_unchanged_columns(self, df_training, df_output):
        """V√©rifie que les autres colonnes n'ont pas chang√©"""
        
        print("\n" + "üîí V√âRIFICATION DES AUTRES COLONNES" + "="*25)
        
        # Colonnes qui ne doivent pas changer
        common_cols = set(df_training.columns) & set(df_output.columns)
        other_cols = [col for col in common_cols if col not in self.target_columns]
        
        changes_detected = 0
        
        for col in other_cols:
            col_changes = 0
            for idx in range(len(df_training)):
                train_val = self._normalize_value(df_training.iloc[idx][col])
                out_val = self._normalize_value(df_output.iloc[idx][col])
                
                if train_val != out_val:
                    col_changes += 1
            
            if col_changes > 0:
                changes_detected += col_changes
                print(f"   ‚ö†Ô∏è {col}: {col_changes} changements d√©tect√©s")
        
        if changes_detected == 0:
            print("   ‚úÖ Parfait! Aucune colonne non-cible n'a √©t√© modifi√©e")
        else:
            print(f"   üö® PROBL√àME: {changes_detected} changements dans les colonnes non-cibles")
        
        self.other_columns_stable = changes_detected == 0
    
    def _normalize_value(self, value):
        """Normalise une valeur"""
        if pd.isna(value) or value is None:
            return ''
        return str(value).strip()
    
    def _print_performance_report(self):
        """Rapport final de performance du syst√®me"""
        
        print("\n" + "="*80)
        print("üìä RAPPORT DE PERFORMANCE FINAL DU SYST√àME")
        print("="*80)
        
        # Performance globale
        overall_accuracy = (self.total_correct / self.total_should_predict * 100) if self.total_should_predict > 0 else 0
        overall_precision = (self.total_correct / self.total_predicted * 100) if self.total_predicted > 0 else 0
        
        print(f"üéØ PERFORMANCE GLOBALE:")
        print(f"   ‚Ä¢ Total de valeurs √† pr√©dire: {self.total_should_predict:,}")
        print(f"   ‚Ä¢ Total de pr√©dictions faites: {self.total_predicted:,}")
        print(f"   ‚Ä¢ Total de pr√©dictions correctes: {self.total_correct:,}")
        print(f"   ‚Ä¢ üìä Pr√©cision g√©n√©rale: {overall_accuracy:.1f}%")
        print(f"   ‚Ä¢ ‚ö° Efficacit√© g√©n√©rale: {overall_precision:.1f}%")
        
        # Performance par colonne
        print(f"\nüìã PERFORMANCE PAR COLONNE:")
        print(f"{'Colonne':<12} {'√Ä Pr√©dire':<10} {'Pr√©dites':<10} {'Correctes':<10} {'Pr√©cision':<10}")
        print("-" * 60)
        
        for col, stats in self.performance_stats.items():
            print(f"{col:<12} {stats['total_should_predict']:<10} {stats['total_predicted']:<10} {stats['correct_predictions']:<10} {stats['accuracy']:<9.1f}%")
        
        # Classement des colonnes par performance
        sorted_cols = sorted(self.performance_stats.items(), key=lambda x: x[1]['accuracy'], reverse=True)
        
        print(f"\nüèÜ CLASSEMENT PAR PERFORMANCE:")
        for i, (col, stats) in enumerate(sorted_cols, 1):
            emoji = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "üìä"
            print(f"   {emoji} {i}. {col}: {stats['accuracy']:.1f}% de pr√©cision")
        
        # Stabilit√© des autres colonnes
        print(f"\nüîí STABILIT√â DES AUTRES COLONNES:")
        if self.other_columns_stable:
            print("   ‚úÖ Toutes les autres colonnes sont stables")
        else:
            print("   ‚ùå Certaines colonnes non-cibles ont √©t√© modifi√©es")
        
        # Verdict final et recommandations
        print(f"\nüí° VERDICT ET RECOMMANDATIONS:")
        
        if overall_accuracy >= 90:
            print("   üéâ EXCELLENT! Le syst√®me de r√®gles fonctionne tr√®s bien")
            print("   ‚úÖ Performance √©lev√©e, syst√®me pr√™t pour la production")
        elif overall_accuracy >= 70:
            print("   üëç BON! Performance satisfaisante")
            print("   üîß Quelques ajustements de r√®gles pourraient am√©liorer")
        elif overall_accuracy >= 50:
            print("   ‚ö†Ô∏è MOYEN! Performance mod√©r√©e")
            print("   üõ†Ô∏è R√©vision des r√®gles recommand√©e")
        else:
            print("   üö® FAIBLE! Performance insuffisante")
            print("   üîÑ R√©vision compl√®te du syst√®me de r√®gles n√©cessaire")
        
        # Recommandations sp√©cifiques
        worst_col = min(sorted_cols, key=lambda x: x[1]['accuracy'])
        best_col = max(sorted_cols, key=lambda x: x[1]['accuracy'])
        
        print(f"\nüéØ ACTIONS PRIORITAIRES:")
        print(f"   üìà Am√©liorer les r√®gles pour '{worst_col[0]}' ({worst_col[1]['accuracy']:.1f}%)")
        print(f"   ‚ú® Reproduire le succ√®s de '{best_col[0]}' ({best_col[1]['accuracy']:.1f}%)")
        
        if not self.other_columns_stable:
            print(f"   üîß Corriger les modifications non-d√©sir√©es dans les autres colonnes")
        
        print("="*80)

def main():
    """Fonction principale"""
    
    comparator = TrainingVsOutputComparator()
    
    # S√©lection des fichiers
    training_file, output_file = comparator.select_files_gui()
    
    if training_file and output_file:
        # Analyser la performance du syst√®me
        comparator.compare_training_vs_output(training_file, output_file)
        
        print(f"\nüéâ Analyse de performance termin√©e!")
        input("\nAppuyez sur Entr√©e pour fermer...")
    else:
        print("‚ùå Analyse annul√©e - fichiers non s√©lectionn√©s")

if __name__ == "__main__":
    main()